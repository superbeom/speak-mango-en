# Project History & Q&A Logs

> 최신 항목이 상단에 위치합니다.

## 2026-01-08: n8n 워크플로우 최적화 및 콘텐츠 품질 고도화 (n8n Workflow Optimization & Quality Improvements)

### ✅ 진행 사항

- **중복 체크 로직 최적화**: `Check Duplicate` 노드에 `Limit: 1` 및 `Always Output Data: On` 설정을 적용하여 성능을 높이고 데이터 부재 시에도 워크플로우가 중단되지 않도록 개선.
- **콘텐츠 생성 규칙 강화**:
  - **대화문 구조 표준화**: 모든 대화문이 2~3턴(A-B 또는 A-B-A)의 간결하고 자연스러운 구성을 갖추도록 프롬프트 수정.
  - **수치 및 통화 표기 통일**: 통화 기호는 항상 `$`(USD)를 사용하고, 1,000 이상의 숫자에는 쉼표(,)를 사용하도록 강제하여 데이터 일관성 확보.
- **운영 안정성 확보**: `Groq Orpheus TTS` 모델 사용 전 약관 동의(Terms of Use)가 필요함을 문서화하고, 미동의 시 발생하는 400 에러 해결 가이드 추가.
- **추후 과제 발굴**: '원어민 대화' 재생 시 볼륨 크기 제어 로직 구현을 `future_todos.md`에 추가.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `Always Output Data` 옵션을 켰나?**

- **A.** Supabase 노드에서 필터링 결과가 없을 경우 기본적으로 에러를 내거나 출력을 하지 않아 다음 노드(`If New`)가 실행되지 않는 문제가 있음. 이 옵션을 켜면 데이터가 없더라도 빈 객체를 반환하므로 워크플로우의 흐름을 안정적으로 제어할 수 있음.

**Q. 대화 턴수를 2~3턴으로 제한한 이유는?**

- **A.** 학습용 콘텐츠로서 너무 긴 대화는 사용자 집중도를 떨어뜨릴 수 있고, TTS 생성 비용 및 시간도 증가함. 핵심 표현을 명확한 맥락에서 보여주기에 가장 효율적인 2~3턴으로 표준화함.

**Q. 왜 달러($) 기호를 강제하나?**

- **A.** 글로벌 영어 학습 서비스로서 통화 단위가 섞여 있으면(원, 엔, 달러 등) 데이터의 통일성이 떨어짐. 가장 보편적인 달러를 기본으로 사용하되, 특정 국가의 문화를 다루는 예외적인 경우에만 다른 통화를 허용함.

## 2026-01-07: n8n 워크플로우 모듈화 및 확장성 강화 (n8n Workflow Modularization & Scalability)

### ✅ 진행 사항

- **문서 구조 재편 (Documentation Reorganization)**:
  - `docs/` 폴더 내의 문서들을 주제별 하위 폴더(`n8n/`, `monetization/`, `git/`, `database/`, `product/`)로 분류하여 관리 효율성 증대.
  - `docs/n8n/` 하위에 `expressions/` 폴더를 신설하여 워크플로우별 문서 격리 및 확장성 확보.
- **코드 노드 개별 파일화**: n8n 워크플로우 내의 복잡한 JavaScript 로직과 AI 프롬프트를 `n8n/expressions/code/` 폴더 내의 개별 파일(`*.js`, `*.txt`)로 분리하여 관리 효율성 증대.
- **워크플로우 구조 정교화**: 템플릿 파일명을 `expressions_workflow_template.json`으로 변경하고 전용 폴더로 이동하여 향후 `vocas` 등 다른 도메인 확장을 위한 구조적 기반 마련.
- **보안성 향상**: 워크플로우 템플릿 내의 특정 Credential ID를 플레이스홀더로 교체하여 공유 및 커밋 시 보안 위험 제거.
- **백업 체계 개선**: 로컬 백업 파일명을 `speak_mango_n8n_expressions_workflow.json`으로 변경하여 명확성 확보.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 문서 폴더 구조를 재편했나?**

- **A.** 프로젝트 문서가 많아짐에 따라 `docs/` 루트에 모든 파일이 나열되어 있어 가독성이 떨어짐. `n8n`, `database`, `product` 등 주제별로 폴더를 나누고, 특히 `n8n`은 워크플로우 종류(`expressions`, `vocas` 등)에 따라 하위 폴더를 두어 확장성을 고려함.

**Q. 왜 코드 노드를 별도 파일로 분리했나?**

- **A.** n8n GUI 내에서 직접 코드를 수정하는 것은 버전 관리와 가독성 측면에서 한계가 있음. 로컬 파일로 분리함으로써 에디터의 기능을 활용하고, 문서와 실제 구현 코드 간의 정합성을 더 쉽게 유지하기 위함임.

**Q. 폴더 구조를 `n8n/expressions/`로 세분화한 이유는?**

- **A.** 현재는 '표현(Expressions)' 생성 워크플로우만 존재하지만, 향후 '단어장(Vocas)', '이미지 생성' 등 성격이 다른 자동화 로직이 추가될 때 서로 섞이지 않고 독립적으로 관리하기 위함임.

## 2026-01-07: TTS 파이프라인 통합 및 문서화 (TTS Integration & Documentation)

### ✅ 진행 사항

- **TTS 파이프라인 구축**: n8n 워크플로우에 `Groq Orpheus TTS`를 연동하여 영어 대화문 생성 시 원어민 음성(WAV)을 자동 합성하고 Supabase Storage에 저장하는 로직 구현.
- **Storage 구조 최적화**:
  - 버킷명을 `speak-mango-en`으로 설정하여 프로젝트 단위 통합 저장소로 격상.
  - 하위 폴더 구조를 `expressions/{id}/{index}.wav`로 정규화하여 확장성 확보.
- **문서 현행화**:
  - `docs/n8n/expressions/optimization_steps.md`, `docs/n8n/expressions/user_guide.md`, `docs/n8n/expressions/workflow_guide.md`에 TTS 관련 상세 설정 및 트러블슈팅 가이드 추가.
  - `docs/database/supabase_strategy.md`에 Storage 폴더 격리 전략 및 향후 유료화(Feature Gating) 시 보안 전환 가이드 수립.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 Storage 버킷 이름을 `speak-mango-en`으로 설정했나?**

- **A.** `expression-audio`는 오디오 전용이라는 느낌이 강했음. 향후 이미지(`images/`), 사용자 프로필(`users/`) 등 다양한 자산을 하나의 버킷에서 효율적으로 관리하기 위해 프로젝트명과 동일한 버킷을 생성하고 하위 폴더로 격리하는 전략(`Folder-based Isolation`)을 채택함.

**Q. TTS 음성 파일은 왜 Public 버킷에 저장하나?**

- **A.** 초기 개발 단계에서의 접근 편의성과 CDN 캐싱 효율을 위해 Public으로 설정함. 단, `docs/product/future_todos.md`에 기록한 대로 추후 유료 사용자 전용 기능(Feature Gating) 도입 시 Private 전환 및 RLS 설정을 적용할 예정임.

## 2026-01-06: 라우트 중앙 관리 및 필터 누적 시스템 (Centralized Routing & Additive Filtering)

### ✅ 진행 사항

- **중앙 관리형 라우트 시스템 도입**: `lib/routes.ts`를 생성하여 앱 내 모든 경로와 필터 조합 로직을 단일 지점에서 관리하도록 구조화. 하드코딩된 문자열을 제거하여 유지보수성 향상.
- **필터 누적(Additive Filtering) 구현**: `ExpressionCard` 내 카테고리/태그 클릭 시 기존 필터를 초기화하는 대신 현재 상태를 유지하며 새로운 필터를 더하는 방식으로 UX 고도화.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 필터 누적 방식을 택했나?**

- **A.** 사용자가 특정 카테고리 내에서 특정 태그가 붙은 항목만 골라보는 등 정교한 탐색을 원할 때, 필터가 초기화되면 다시 설정해야 하는 번거로움이 있음. 현대적인 서비스의 필터링 관례에 맞춰 사용자 경험을 상향 평준화함.

## 2026-01-06: 카테고리 필터링 최적화 (Toggle & Duplicate Prevention)

### ✅ 진행 사항

- **카테고리 토글(Toggle) 기능 구현**: 이미 선택된 카테고리를 다시 클릭할 경우 필터가 해제되어 '전체' 목록으로 돌아가도록 UX 개선.
- **중복 페칭 방지**: '전체' 카테고리가 선택된 상태에서 '전체'를 다시 누를 경우 아무 동작도 하지 않도록 차단하여 불필요한 네트워크 요청 제거.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 '전체' 클릭 시에는 아무 동작도 안 하게 했나?**

- **A.** 이미 모든 데이터를 보여주는 상태에서 다시 '전체'를 누르는 것은 의미 없는 중복 데이터 페칭만 유발함. 성능 최적화와 사용자 실수 방지를 위해 해당 동작을 무시하도록 처리함.

**Q. 토글 방식의 장점은?**

- **A.** 사용자가 필터를 해제하기 위해 매번 '전체' 버튼을 찾아서 누를 필요 없이, 보던 카테고리를 한 번 더 누르는 것만으로 초기 상태로 돌아갈 수 있어 탐색 속도가 향상됨.

## 2026-01-06: 네비게이션 상태 보존 고도화 (Multi-cache & Robust Scroll Restoration)

### ✅ 진행 사항

- **Multi-cache 시스템 구축**: 필터 조합(URL)별로 리스트 데이터와 스크롤 위치를 독립적으로 저장하는 `ExpressionContext` 고도화. 검색 결과, 카테고리별 목록 등 각기 다른 탐색 맥락을 완벽히 격리 보존.
- **실시간 스크롤 추적**: 디바운스가 적용된 실시간 리스너를 통해 페이지 이동 클릭 시점뿐만 아니라 브라우저 뒤로가기 등 모든 상황에서의 위치 저장을 자동화.
- **재귀적 RAF 복원 로직**: `requestAnimationFrame`을 사용하여 레이아웃이 확정될 때까지 최대 1초간 추적하며 정확한 위치로 스크롤을 이동시키는 강력한 복원 엔진 구현.
- **컴포넌트 생명주기 최적화**: 필터 변경 시 컴포넌트의 `key` prop을 교체하여 완전한 초기화 및 캐시 복원 프로세스 강제.
- **BackButton 컴포넌트**: 브라우저 히스토리 기반의 뒤로가기 기능 및 직접 진입 시를 위한 홈 이동 안전장치 구현.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `ResizeObserver` 대신 재귀적 `RAF` 방식을 택했나?**

- **A.** `ResizeObserver`는 요소의 크기 변화만 감지하지만, `Framer Motion` 애니메이션이나 폰트 로딩 등으로 인한 미세한 레이아웃 시프트는 브라우저의 페인팅 주기와 밀접하게 연관됨. 재귀적 `RAF`는 브라우저가 화면을 그리는 시점에 맞춰 여러 번 보정하므로 시각적 완성도와 복원 정확도가 훨씬 높음.

**Q. 왜 실시간으로 스크롤 위치를 저장하나?**

- **A.** 상세 페이지로 넘어가는 클릭 시점(`onClick`)에만 저장하면, 브라우저 자체의 뒤로가기 버튼을 눌러 나가는 상황이나 의도치 않은 언마운트 시 대응이 불가능함. 사용자 경험의 연속성을 위해 실시간 저장 방식을 채택함.

## 2026-01-06: 네비게이션 상태 보존 (Scroll Restoration & State Persistence)

### ✅ 진행 사항

- **전역 상태 관리 도입**: `ExpressionContext`를 생성하여 페이지 이동 간에도 리스트 데이터, 페이지 번호, 필터 상태를 유지하도록 구현.
- **스크롤 복원 구현**: 상세 페이지에서 뒤로가기 시, 이전 리스트의 스크롤 위치를 정확히 복원하는 로직(`useLayoutEffect`) 추가.
- **BackButton 컴포넌트**: `router.back()`을 사용하여 브라우저 히스토리를 활용하는 뒤로가기 버튼 구현 (안전장치 포함).

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `Context API`를 사용했나?**

- **A.** Next.js App Router에서 페이지 이동 시 클라이언트 컴포넌트의 상태는 초기화됨. '더 보기'로 불러온 데이터가 사라지는 문제를 해결하기 위해, 상태를 최상위(`layout.tsx`)로 끌어올려 전역에서 관리해야 했음.

**Q. `BackButton`에서 `router.push('/')`는 왜 필요한가?**

- **A.** SNS 공유 등으로 상세 페이지에 바로 진입(Deep Link)했을 때는 브라우저 히스토리가 없음. 이때 `router.back()`은 작동하지 않으므로, 사용자가 갇히지 않고 메인으로 이동할 수 있도록 Fallback을 제공함.

## 2026-01-05: 리스트 애니메이션 최적화 및 UI/UX 폴리싱

### ✅ 진행 사항

- **리스트 레이아웃 안정화**: `AnimatedList` 컴포넌트에서 `layout` 속성을 제거하여 '더 보기' 버튼 클릭으로 새로운 아이템이 추가될 때 기존 아이템들이 의도치 않게 움직이거나 깜빡이는 현상 해결.
- **카드 진입 애니메이션 개선**: `ExpressionCard`의 등장 효과를 Slide-up(`y: 20`) 방식에서 Scale-up(`scale: 0.96 -> 1.0`) 방식으로 변경. 보다 세련되고 몰입감 있는 시각적 경험 제공.
- **트랜지션 성능 최적화**: 카드 애니메이션 지속 시간을 0.5초에서 0.4초로 단축하고 베지어 곡선(Ease)을 조정하여 더욱 경쾌한 반응성 확보.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `layout` 속성을 제거했나?**

- **A.** Framer Motion의 `layout` 속성은 요소의 크기나 위치가 바뀔 때 자동으로 애니메이션을 적용해주지만, 무한 스크롤이나 '더 보기'처럼 리스트가 아래로 계속 늘어나는 구조에서는 때때로 이전 아이템들이 불필요하게 재계산되어 덜컥거리는 느낌(Jitter)을 줄 수 있음. 성능과 시각적 안정성을 위해 이를 제거함.

**Q. 등장 애니메이션을 Scale로 바꾼 이유는?**

- **A.** Slide-up 방식은 아래에서 위로 올라오는 느낌이 강해 시선이 분산될 수 있음. 반면 Scale-up은 제자리에서 피어오르는 듯한 느낌을 주어 사용자가 새롭게 로드된 콘텐츠에 더 자연스럽게 집중할 수 있도록 도움.

## 2026-01-05: 리스트 탐색 경험 개선 ('더 보기' 구현 및 스크롤 리셋)

### ✅ 진행 사항

- **스크롤 자동 리셋**: 상세 페이지 진입 시 스크롤이 유지되는 문제를 해결하기 위해 Next.js 표준 방식인 `template.tsx` 도입.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 스크롤 리셋을 위해 `useEffect` 대신 `template.tsx`를 썼나?**

- **A.** `layout.tsx`는 페이지 이동 시 상태를 유지하지만, `template.tsx`는 매번 새롭게 마운트됨. 프레임워크 수준에서 페이지 전환 시 초기화 로직(스크롤 리셋 등)을 처리하기 위한 가장 깨끗하고 공식적인 방법임.

## 2026-01-05: 리스트 탐색 경험 개선 ('더 보기' 버튼 구현)

### ✅ 진행 사항

- **페이지네이션 도입**: `lib/expressions.ts`의 `getExpressions` 함수를 수정하여 `page`, `limit` 파라미터 기반의 범위 조회(`range`) 로직 구현.
- **서버 액션(Server Action) 생성**: 클라이언트 컴포넌트에서 안전하게 다음 페이지 데이터를 요청할 수 있도록 `lib/actions.ts`에 `fetchMoreExpressions` 액션 추가.
- **ExpressionList 컴포넌트 구현**: 초기 데이터와 추가 데이터를 통합 관리하고 '더 보기' 인터랙션을 처리하는 전용 클라이언트 컴포넌트 구축.
- **컴포넌트 모듈화**: '더 보기' 버튼을 독립 컴포넌트(`LoadMoreButton.tsx`)로 분리하고, 리스트 관리 로직을 `ExpressionList.tsx`로 캡슐화.
- **UI/UX 최적화**:
  - 추가 로딩 시 `SkeletonCard`를 사용하여 레이아웃 흔들림 방지.
  - 다크모드에서의 버튼 시인성 개선 및 모바일 터치 호버 방지(`useEnableHover`).
  - 버튼 호버 애니메이션 추가 및 데이터 소진 시 버튼 자동 숨김 처리.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 무한 스크롤(Infinite Scroll) 대신 '더 보기' 버튼을 선택했나?**

- **A.** 무한 스크롤은 사용자가 푸터(Footer)에 접근하는 것을 방해하고, 원치 않는 데이터 로딩으로 인해 피로감을 줄 수 있음. 사용자가 명시적으로 '더 보기'를 누르게 함으로써 탐색의 주도권을 제공하고 성능을 최적화함.

**Q. 왜 `actions.ts`를 별도로 분리했나?**

- **A.** Next.js App Router 규칙에 따라 서버 액션은 `"use server"` 지시어가 포함된 별도 파일에 관리하는 것이 클라이언트 컴포넌트와의 충돌을 방지하고 코드 구조를 명확히 하는 데 유리함.

**Q. '더 보기' 버튼을 왜 독립 컴포넌트로 만들었나?**

- **A.** 버튼의 스타일(다크모드 대응, 호버 애니메이션 등)이 복잡해짐에 따라 리스트 로직과 UI 관심사를 분리하여 유지보수성을 높이고, 향후 다른 리스트에서도 재사용하기 위함임.

## 2026-01-05: 스켈레톤 로딩 (Skeleton Loading) 구현 및 UX 최적화

### ✅ 진행 사항

- **스켈레톤 시스템 구축**: 데이터 페칭 중 레이아웃 흔들림(CLS)을 방지하고 체감 속도를 높이기 위해 `Skeleton` 컴포넌트 시리즈 구현.
- **맞춤형 스켈레톤 설계**:
  - `SkeletonNavbar`: 메인(로고+서브헤더)과 상세(뒤로가기) 페이지의 헤더 구조에 맞춘 변주 지원.
  - `SkeletonHomeHero`: 홈 페이지 상단 타이틀과 설명 영역 공간 확보.
  - `SkeletonDetail`: 상세 페이지의 메인 카드, 대화 블록, 퀴즈 카드 구조를 정교하게 모사.
- **전역 로딩 적용**: `app/loading.tsx`와 `app/expressions/[id]/loading.tsx`를 생성하여 Next.js App Router의 내장 스트리밍 로딩 기능 활용.
- **전략 문서화**: `docs/project_context.md`에 새로운 데이터 의존 컴포넌트 생성 시 스켈레톤 구현을 의무화하는 규칙 추가.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 Client Component 내부에 로딩 상태를 두지 않고 `loading.tsx`를 썼나?**

- **A.** 서버 컴포넌트에서 데이터를 가져오는 동안 페이지 전체의 레이아웃 일관성을 유지하고, Next.js의 스트리밍 기능을 최대한 활용하여 첫 바이트 도달 시간(TTFB)을 최적화하기 위함임.

**Q. 스켈레톤 디자인 시 가장 고려한 점은?**

- **A.** 실제 콘텐츠가 로드되었을 때 요소의 위치가 바뀌지 않도록(Zero CLS), 실제 컴포넌트와 동일한 패딩, 여백, 최소 높이 값을 적용하는 데 집중함.

## 2026-01-05: Scroll To Top 기능 구현 및 모바일 최적화

### ✅ 진행 사항

- **ScrollToTop 컴포넌트 생성**: 스크롤이 일정 깊이(300px) 이상 내려가면 우측 하단에 나타나는 상단 이동 버튼 구현.
- **애니메이션 및 반응형**: `framer-motion`을 사용하여 부드러운 등장/퇴장 효과를 적용하고, 모바일과 데스크탑 환경에 맞춰 버튼 크기와 위치를 최적화함.
- **전역 적용**: `app/layout.tsx`에 배치하여 모든 페이지에서 일관되게 동작하도록 설정.
- **코드 리팩토링**: `useScroll` 훅을 재사용하여 스크롤 감지 로직을 간소화하고, `useEnableHover`를 통해 모바일 터치 호버 문제를 방지함.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `layout.tsx`에 배치했나?**

- **A.** 스크롤이 길어지는 상황은 메인 리스트뿐만 아니라 상세 페이지 등 서비스 전반에서 발생할 수 있으므로, 페이지마다 중복 코드를 작성하는 대신 레이아웃 레벨에서 전역으로 관리하는 것이 효율적임.

## 2026-01-05: 모바일 UX 최적화 및 기술 구현 문서화 및 n8n 태그 생성 로직 고도화

### ✅ 진행 사항

- **태그 생성 규칙 명문화**: `docs/n8n/expressions/optimization_steps.md` 및 `n8n/n8n_workflow_template.json`에 태그 생성 필수 요건(Requirement 11)을 추가. AI가 3~5개의 소문자 키워드를 포함하도록 명시하여 데이터 품질 및 필터링 효율성을 높임.
- **모바일 호버 이슈 해결**: 모바일에서 스크롤 시 카드의 호버 효과(크기 변경, 테두리 색상)가 유지되거나 깜빡이는 문제를 해결하기 위해 `useIsMobile` 훅을 활용.
- **조건부 렌더링**: 모바일 환경(`isMobile === true`)에서는 `whileHover`, `whileTap` 애니메이션과 CSS `hover:` 클래스가 적용되지 않도록 `ExpressionCard` 컴포넌트 로직 수정.
- **안정성 확보**: 초기 렌더링 시(`undefined`) 데스크탑을 기본값으로 간주하여 하이드레이션 불일치 방지 및 점진적 적용.
- **필터 UX 개선**: `FilterBar`에서 카테고리 선택 시, 선택된 칩이 자동으로 화면 중앙으로 스크롤되도록 로직 구현(`data-category` 속성 활용).
- **기술 문서 작성**: 프로젝트의 핵심 기술 구현 상세(i18n, 데이터 아키텍처, UI 자동화 등)를 정리한 `docs/technical_implementation.md` 생성.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 모바일에서 호버를 껐나?**

- **A.** 터치 디바이스에서는 손가락이 닿는 순간을 `hover`로 인식하는 경우가 많아, 스크롤 중에 카드가 눌리거나 색이 변하는 등 의도치 않은 시각적 피드백이 발생함. 깔끔한 스크롤 경험을 위해 모바일에서는 호버 효과를 제거함.

**Q. 기술 문서를 왜 따로 만들었나?**

- **A.** 모바일 감지, 무한 스크롤 가속, 필터 자동 스크롤 등 UI/UX와 관련된 복잡한 기술 로직이 늘어남에 따라, 이를 코드 주석으로만 남기기보다 별도의 문서로 정리하여 유지보수성과 이해도를 높이기 위함임.

## 2026-01-05: 관련 표현 추천 드래그 가속 기능 구현 및 안정화

### ✅ 진행 사항

- **데스크탑 스크롤 인터랙션 고도화**: 상세 페이지 하단의 '관련 표현 추천' 섹션에서, 좌우 페이드 영역에 마우스를 올리면 해당 방향으로 스크롤이 빠르게 가속되는 기능을 추가함.
- **양방향 무한 루프 구현**: 기존의 단방향(오른쪽) 무한 루프를 보완하여, 가속 기능을 통해 왼쪽 끝에 도달했을 때도 끊김 없이 오른쪽 끝으로 연결되도록 로직을 개선함.
- **시각적 피드백 강화**: 페이드 영역 호버 시 전용 커서(`w-resize`, `e-resize`)를 제공하고 히트 영역을 `w-24`로 확장하여 사용성을 높임.
- **버그 수정 (Stacking Context & Events)**:
  - 페이드 영역이 카드 콘텐츠보다 아래(`z-index`)에 있어 호버 이벤트가 발생하지 않던 문제를 `z-index: 20` 상향 및 DOM 순서 변경으로 해결.
  - `fade-mask-base`의 `pointer-events-none` 속성으로 인해 이벤트가 차단되던 문제를, 페이드가 보일 때(`opacity-100`) `pointer-events-auto`를 명시적으로 추가하여 해결.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 페이드 영역에 가속 기능을 추가했나?**

- **A.** 자동 스크롤(Marquee)은 시선을 끄는 데 효과적이지만, 사용자가 특정 표현을 빨리 찾고 싶을 때 답답함을 느낄 수 있음. 페이드 영역을 "가속 버튼"처럼 활용하게 함으로써, 별도의 버튼 UI 없이도 직관적으로 스크롤 속도를 제어할 수 있는 UX를 제공함.

## 2026-01-04: 사용자 가이드 작성 및 퀴즈 UI 개선

### ✅ 진행 사항

- **사용자 가이드 작성**: 서비스 개요부터 n8n 워크플로우 설정 방법까지 상세히 안내하는 `docs/n8n/expressions/user_guide.md` 생성. 운영자가 워크플로우를 직접 설정하고 운영하는 데 필요한 모든 단계(Credentials, Node Logic, Troubleshooting)를 문서화함.
- **퀴즈 UI 가독성 개선**: 상세 페이지의 퀴즈 질문(`question`) 영역에 `whitespace-pre-wrap` 속성을 추가하여, n8n에서 생성된 줄바꿈(`\n`)이 UI에 그대로 반영되도록 수정. 이를 통해 질문과 선택지가 섞여 보이던 문제를 해결함.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 퀴즈 질문에 `whitespace-pre-wrap`을 적용했나?**

- **A.** Gemini가 생성하는 퀴즈 데이터는 질문과 선택지 사이, 혹은 긴 문장 사이의 가독성을 위해 개행 문자(`\n`)를 포함함. 기존 CSS에서는 이를 무시하고 한 줄로 붙여서 보여주었기에 가독성이 매우 떨어졌음. CSS 속성 하나로 데이터가 의도한 레이아웃대로 출력되도록 개선함.

## 2026-01-04: n8n 퀴즈 생성 로직 고도화 및 데이터 무결성 확보

### ✅ 진행 사항

- **Quiz Logic 재정립**: `docs/n8n/expressions/optimization_steps.md`의 Gemini 프롬프트를 전면 개편.
  - 기존의 모호하거나 잘못된 패턴(Target Language -> Target Language)을 제거하고, 3가지 명확한 패턴(Situation->EN, Expression->Situation, Negative Logic)으로 정립.
  - 모든 언어(KO, JA, ES)에 대해 3지 선다(A/B/C)와 정답 포맷(단일 알파벳)을 강제하는 **Strict Formatting Rules** 추가.
- **데이터 보정**: 기존 DB에 쌓인 잘못된 형식의 퀴즈 데이터(`How's it going?`, `down in the dumps` 등)와 논리적으로 부적절한 데이터(`Is there a fitting room?` 등)를 올바른 패턴으로 수정하는 SQL 스크립트 작성 (`database/009_fix_invalid_quizzes.sql`).

### 💬 주요 Q&A 및 의사결정

**Q. 왜 기존 퀴즈 패턴(Pattern 3)을 삭제했나?**

- **A.** 기존 Pattern 3은 "한국어 상황"을 주고 "한국어 대사"를 고르는 방식이었는데, 이는 영어 학습 목적에 부합하지 않음. 대신 '부적절한 상황 고르기(Negative Logic)'를 Pattern 3으로 새로 정의하여 학습 효과를 높임.

**Q. SQL에서 Dollar Quoting(`$$`)을 사용한 이유는?**

- **A.** JSONB 데이터 내부에 싱글 쿼테이션(`'`)이 포함된 텍스트(예: `How's it going?`)를 업데이트할 때, 일반적인 이스케이핑 방식으로는 구문 오류가 발생하기 쉬움. `$$`를 사용하여 쿼리의 가독성을 높이고 이스케이프 문제를 원천 차단함.

## 2026-01-03: n8n 프롬프트 최적화 및 문서 워크플로우 개선

### ✅ 진행 사항

- **Gemini 프롬프트 고도화**: `Gemini Content Generator` 프롬프트를 수정하여 영어 표현의 대소문자(문장 vs 구절), 의미의 톤(반말 vs 존댓말), 문장 부호(물음표 등) 규칙을 명확히 정의함.
- **컨텍스트 복원 강화**: `.agent/workflows/restore_context.md`가 로드하는 파일 목록에 `features_list.md`, `database/schema.md`를 추가하여 에이전트의 이해도 향상.
- **문서 동기화**: `n8n_optimization_steps.md`와 `n8n/n8n_workflow_template.json`을 최신 프롬프트 변경 사항에 맞춰 업데이트.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 "No worries"는 대문자, "spill the tea"는 소문자로 시작하게 했나?**

- **A.** 독립된 문장이나 감탄사는 대문자로 시작하는 것이 자연스럽고, 문장 속에 삽입되는 관용구는 소문자로 시작해야 활용하기 좋기 때문임.

**Q. 의미(Meaning) 필드에서 존댓말을 허용한 이유는?**

- **A.** 기존에는 무조건 반말을 강제했으나, "Could I...?" 같이 정중한 영어 표현을 "해 줄래?"로 번역하면 뉘앙스가 어긋남. 따라서 영어 표현 자체가 정중할 경우 한국어 뜻풀이도 존댓말을 사용하도록 예외 규칙을 추가함.

## 2026-01-03: UI 스타일 중앙 관리 및 모바일 최적화

### ✅ 진행 사항

- **공통 유틸리티 클래스 도입**: `globals.css`에 반복되는 UI 패턴(배경, 테두리, 텍스트 색상 등)을 `bg-surface`, `bg-subtle`, `text-body` 등 전역 유틸리티 클래스로 정의하여 통합 관리.
- **모바일 감지 훅 구현**: `useMediaQuery`와 `useIsMobile` 훅을 추가하여 클라이언트 사이드에서 정확한 모바일 환경 감지 로직 구축.
- **하이드레이션 이슈 해결**: 모바일 감지 시 SSR과 CSR 간의 불일치로 발생하는 Hydration Mismatch 문제를 초기값 `undefined` 처리 및 동적 렌더링을 통해 해결.
- **컴포넌트 리팩토링**: `ExpressionCard`, `SearchBar`, `FilterBar`, `RelatedExpressions` 등 주요 컴포넌트가 전역 유틸리티와 모바일 훅을 사용하도록 전면 리팩토링.
- **문서 체계 강화**: 에이전트 워크플로우(`update_docs`)에 `feature_ideas.md`를 포함시키고, 구현 완료된 아이템의 관리 규칙을 명시함.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 Tailwind 클래스를 직접 쓰지 않고 유틸리티 클래스를 따로 정의했나?**

- **A.** `bg-white dark:bg-zinc-900` 같은 조합이 수십 개의 컴포넌트에서 반복되면, 나중에 테마 색상을 변경할 때 모든 파일을 수정해야 함. `bg-surface`와 같이 시맨틱한 이름을 사용하면 `globals.css` 한 곳만 수정해도 전체 앱의 디자인을 일관되게 바꿀 수 있음.

**Q. 왜 `isMobile`의 초기값을 `false`가 아닌 `undefined`로 두었나?**

- **A.** 서버 사이드에서는 화면 크기를 알 수 없으므로 `false`로 가정하면, 실제 모바일 기기에서 접속했을 때 서버는 데스크탑 뷰를 보내고 클라이언트는 모바일 뷰로 그려 하이드레이션 에러가 발생함. `undefined`를 반환하고 클라이언트에서 값이 확정된 후 그리게 함으로써 이를 방지함.

## 2026-01-03: 아키텍처 정비 및 Sticky UI 고도화

### ✅ 진행 사항

- **폴더 구조 재편**: `lib/hooks`와 `lib/i18n`을 루트 레벨(`hooks/`, `i18n/`)로 이동하여 아키텍처 명확성 확보.
- **공통 훅 도입**: `useScroll` 훅을 생성하여 헤더와 필터 바의 스크롤 감지 로직을 통합.
- **Sticky UI 개선**: 헤더와 필터 바가 스크롤 시 자연스럽게 연결되도록 디자인 및 로직(Border 토글, 배경색 전환) 개선.
- **전역 스타일 체계 구축**: `globals.css`에 Tailwind v4 테마 변수와 유틸리티를 정의하여 레이아웃 폭, 헤더 높이 등을 중앙 관리.
- **에이전트 워크플로우 모듈화**: 문서 현행화를 자동화하는 `update_docs` 워크플로우를 구축하고 커밋 프로세스에 통합.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 hooks와 i18n 폴더를 루트로 옮겼나?**

- **A.** 프로젝트 규모가 커짐에 따라 `lib` 폴더가 비대해지는 것을 방지하고, 전역적으로 사용되는 핵심 모듈들을 더 직관적으로 찾을 수 있도록 루트 레벨로 승격시킴.

**Q. Sticky UI에서 Border를 왜 동적으로 토글하나?**

- **A.** 평소에는 헤더 하단에 선이 있지만, 필터 바가 헤더 아래에 붙을 때는 헤더의 선이 사라지고 필터 바 하단에 선이 생겨야 두 요소가 하나의 완성된 "상단 바"처럼 보이기 때문임.

## 2026-01-03: 기능 명세 문서화 (Features List)

### ✅ 진행 사항

- **문서화**: 프로젝트의 현재 구현된 기능들을 일목요연하게 정리한 `docs/product/features_list.md` 생성.
- **범위**: 사용자 인터페이스(메인, 상세)부터 백엔드 인프라(Supabase, n8n)까지 전체 시스템 기능 명세 포함.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 기능 목록 문서를 별도로 만들었나?**

- **A.** 개발 히스토리(`project_history.md`)는 시간 순서대로 기록되어 현재 시점의 완성된 기능 스펙을 한눈에 파악하기 어려움. 따라서 신규 개발자나 이해관계자가 현재 서비스의 기능을 빠르게 파악할 수 있도록 Living Document 형태의 기능 명세서를 작성함.

## 2026-01-02: 관련 표현 추천 UI 고도화 (Auto-Marquee)

### ✅ 진행 사항

- **자동 스크롤 구현**: `requestAnimationFrame`을 사용하여 끊김 없이 흐르는 무한 루프 스크롤(Infinite Loop) 구현.
- **인터랙션 강화**: 마우스 호버 시 스크롤 일시정지, 마우스 이탈 시 재개 기능 추가.
- **성능 최적화**: `useCallback` 및 `useEffect` 의존성 최적화로 불필요한 리렌더링 방지.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 자동 스크롤(Auto-Marquee)을 적용했나?**

- **A.** 정적인 리스트보다 움직이는 리스트가 사용자의 시선을 더 잘 끌며, "더 많은 콘텐츠가 있다"는 것을 암시적으로 전달하기 위함임. 또한, 마우스 호버 시 멈추게 하여 사용자가 읽는 데 불편함이 없도록 배려함.

## 2026-01-02: n8n 중복 생성 방지 로직 강화 (Pre-fetch Check)

### ✅ 진행 사항

- **로직 개선**: 기존의 사후 중복 체크(Check Duplicate) 방식이 Gemini의 반복 생성을 막지 못하는 문제를 해결하기 위해, 생성 전 기존 데이터를 조회하여 제외 목록으로 전달하는 **사전 예방(Pre-fetch)** 단계를 추가함.
- **문서 업데이트**: `docs/n8n/expressions/optimization_steps.md` 및 `docs/n8n/expressions/workflow_guide.md`에 'Get Existing Expressions' 단계 추가.

### 💬 주요 Q&A 및 의사결정

**Q. 사후 체크만으로 충분하지 않았나?**

- **A.** 사후 체크(`If New`)는 중복 시 저장을 막을 뿐, 워크플로우를 재실행하거나 다른 표현을 다시 생성하지 않음. 따라서 Gemini가 계속 같은 표현("Touch base" 등)만 생성하면 데이터가 쌓이지 않는 문제가 발생함. 이를 해결하기 위해 **생성 단계에서부터** 이미 있는 표현을 배제하도록 개선함.

## 2026-01-02: n8n 중복 체크 로직 개선 (ILIKE 도입)

### ✅ 진행 사항

- **중복 검사 강화**: n8n 워크플로우의 'Check Duplicate' 노드 설정을 변경.
  - 기존: `Equal` 연산자 (정확히 일치해야 함).
  - 변경: **`ILIKE` (Case-insensitive Like)** 연산자 + 와일드카드(`*`).
  - 예: "touch base" 생성 시, DB에 "Let's touch base"가 있어도 중복으로 감지하여 생성 스킵.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `Equal` 대신 `ILIKE`를 사용했나?**

- **A.** AI가 매번 동일한 표현을 생성하더라도, 문장 부호나 대소문자, 관사 유무 등이 미세하게 다를 수 있음. 단순 `Equal`로는 이를 걸러내지 못해 데이터베이스에 유사 중복 데이터가 쌓이는 문제가 발생할 수 있어, 보다 유연한 `ILIKE` 검색으로 개선함.

## 2026-01-02: 서비스 명칭 변경 및 다국어 확장 아키텍처 수립

### ✅ 진행 사항

- **브랜드 리뉴얼**: 서비스 명칭을 `Daily English`에서 **`Speak Mango`**로 공식 변경.
- **상수화 및 코드 반영**:
  - `lib/constants.ts`에 `SERVICE_NAME` 상수를 추가하고 모든 UI와 메타데이터에서 참조하도록 수정.
  - 서비스 패키지명(`package.json`) 및 로컬 디렉토리 참조 구조 업데이트.
- **다국어 DB 전략 정립**:
  - **콘텐츠 스키마 분리**: 언어별 독립 스키마(`speak_mango_en`, `speak_mango_ko` 등) 사용 결정.
  - **공유 스키마 도입**: 사용자 프로필 및 통합 단어장 관리를 위한 `speak_mango_shared` 스키마 설계.
  - **서비스 격리**: `auth.users`를 공유하되 스키마별 `profiles` 테이블의 존재 여부로 서비스 가입자를 구분하는 보안 전략 수립.
- **클라이언트 유틸리티 고도화**: 스키마 이름을 인자로 받아 동적으로 Supabase 클라이언트를 생성할 수 있도록 `createBrowserSupabase` 및 `createServerSupabase` 함수 개선.
- **DB 마이그레이션**: 기존 `daily_english` 스키마를 `speak_mango_en`으로 변경하는 마이그레이션 스크립트 작성 (`database/008_rename_schema_to_speak_mango.sql`).

### 💬 주요 Q&A 및 의사결정

**Q. 왜 단일 테이블 대신 스키마 분리 방식을 선택했나?**

- **A.** 언어별로 콘텐츠 구조(컬럼 등)가 달라질 수 있는 유연성을 확보하고, 특정 서비스의 데이터 장애가 다른 서비스로 전파되는 것을 막기 위함임. 또한, 향후 특정 언어 서비스만 별도로 분리하거나 매각해야 할 경우 관리가 훨씬 용이함.

**Q. 서로 다른 서비스 간 사용자 로그인을 어떻게 구분하나?**

- **A.** Supabase의 `auth.users`는 공유하되, 각 서비스의 스키마 내에 `auth.users.id`를 외래키로 갖는 `profiles` 테이블을 둠으로써, 해당 테이블에 레코드가 있는 사용자만 가입자로 간주하는 논리적 격리 방식을 채택함.

## 2026-01-02: 관련 표현 추천 구현 및 콘텐츠 탐색 전략 수립

### ✅ 진행 사항

- **관련 표현 추천 구현**:
  - 상세 페이지(`app/expressions/[id]/page.tsx`) 하단에 현재 표현과 동일한 카테고리의 다른 표현들을 추천하는 섹션 추가.
  - `lib/expressions.ts`에 `getRelatedExpressions` 함수를 추가하여 데이터 로직 분리.
- **콘텐츠 탐색 전략 수립**:
  - 향후 데이터 증가에 대비하여 **'더 보기(Load More)'** 방식의 페이지네이션 도입 결정.
  - 탐색 편의성을 극대화하기 위해 **A-Z 인덱스** 및 **업로드 순 인덱스**를 포함한 아카이브 페이지 기획 추가.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 무한 스크롤 대신 '더 보기' 버튼을 선택했나?**

- **A.** 무한 스크롤은 푸터(Footer) 접근성을 저해하고 사용자에게 통제 불가능한 피로감을 줄 수 있음. '더 보기' 버튼은 푸터 접근성을 보장하면서도 사용자가 명시적으로 다음 데이터를 요청하게 함으로써 더 나은 탐색 경험을 제공함.

**Q. 인덱스 페이지의 역할은?**

- **A.** 카테고리/태그 필터링 외에, 사용자가 전체 콘텐츠의 양을 가늠하고 알파벳 순서나 시간 순서로 빠르게 원하는 표현을 '색인(Indexing)' 할 수 있도록 돕는 도서관 카탈로그 같은 역할을 수행함.

## 2026-01-02: Framer Motion 애니메이션 적용 및 데이터 표준화

### ✅ 진행 사항

- **애니메이션 고도화**:
  - `framer-motion` 라이브러리를 도입하여 리스트 및 카드에 생동감 있는 인터랙션 적용.
  - `AnimatedList` 컴포넌트를 통해 검색/필터링 시 카드가 부드럽게 재배치되는 Layout Animation 구현.
  - `ExpressionCard`에 Staggered 진입 효과(순차적 등장) 및 Hover/Tap 피드백 추가.
- **데이터 품질 개선**:
  - `database/007_fix_meaning_style.sql` 스크립트를 통해 `meaning` 컬럼의 문장 끝 마침표(`.`)를 일괄 제거.
  - 기존 데이터 중 존댓말(`~요`, `~세요`)로 작성된 항목들을 프로젝트 규칙에 맞게 반말 스타일로 교정.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `AnimatedList`라는 별도 컴포넌트를 만들었나?**

- **A.** `AnimatePresence`와 `layout` 속성을 효과적으로 관리하기 위함임. 메인 페이지의 코드를 깔끔하게 유지하면서, 추후 다른 리스트(예: 북마크 목록)에서도 동일한 애니메이션 경험을 재사용할 수 있도록 설계함.

**Q. 왜 의미(Meaning) 필드에서 마침표를 제거하고 반말로 통일했나?**

- **A.** `docs/n8n/expressions/optimization_steps.md`에서 정의한 '간결한 뜻풀이'와 '캐주얼한 톤' 원칙을 지키기 위함임. 특히 모바일 카드 UI에서는 텍스트의 간결함이 가독성에 큰 영향을 미치므로 마침표 같은 불필요한 문장 부호를 최소화함.

## 2026-01-01: CategoryLabel 호버 애니메이션 고도화

### ✅ 진행 사항

- **인터랙션 개선**: `CategoryLabel` 컴포넌트 자체에 `group` 클래스를 추가하여, 상세 페이지와 같이 부모에 `group`이 없는 환경에서도 카테고리 아이콘의 호버 애니메이션(`rotate-12`)이 작동하도록 개선.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 컴포넌트에 `group`을 추가했나?**

- **A.** 메인 페이지의 카드는 카드 전체 호버 시 아이콘이 반응하지만, 상세 페이지에서는 카테고리 라벨 자체에 마우스를 올렸을 때 반응해야 함. 컴포넌트가 스스로 호버 상태를 감지할 수 있게 함으로써 범용성을 높임.

## 2026-01-01: CategoryLabel 컴포넌트 추가 및 인터랙션 강화

### ✅ 진행 사항

- **CategoryLabel 컴포넌트 생성**: `components/CategoryLabel.tsx`를 생성하여 카테고리 표시 UI를 캡슐화하고 링크/버튼 동작을 통합 지원.
- **필터링 연동**:
  - `ExpressionCard`: 카테고리 클릭 시 해당 카테고리로 필터링된 메인 페이지로 이동(`/?category=...`)하도록 `handleCategoryClick` 구현.
  - `ExpressionDetailPage`: 상세 페이지 상단의 카테고리를 클릭 가능한 `Link`로 변경하여 필터링 기능 연결.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 Tag와 비슷하게 Category도 별도 컴포넌트로 만들었나?**

- **A.** 카테고리 역시 태그처럼 클릭 시 필터링 기능을 제공해야 하며, 메인(버튼)과 상세(링크) 페이지에서 일관된 스타일을 유지해야 하므로 별도 컴포넌트로 분리하여 재사용성을 높임.

## 2026-01-01: 스타일 충돌 방지를 위한 유틸리티 도입

### ✅ 진행 사항

- **패키지 설치**: `tailwind-merge`와 `clsx`를 설치하여 Tailwind 클래스 병합 로직 강화.
- **유틸리티 추가**: `lib/utils.ts`에 `cn` 함수를 추가하여 조건부 클래스 및 스타일 충돌 해결 기능 제공.
- **컴포넌트 리팩토링**: `Tag.tsx`에서 단순 문자열 연결 대신 `cn` 함수를 사용하도록 수정하여, 외부에서 주입된 클래스가 기본 스타일을 올바르게 덮어쓰도록 개선.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `cn` 유틸리티를 도입했나?**

- **A.** 단순 문자열 연결(`${base} ${custom}`)은 CSS 정의 순서에 따라 스타일 적용 우선순위가 결정되므로, 의도한 대로 스타일 오버라이딩이 되지 않는 문제(Cascading Issue)가 발생할 수 있음. 이를 방지하고 유지보수성을 높이기 위해 도입함.

## 2026-01-01: Tag 컴포넌트 독립 분리 및 재사용성 확보

### ✅ 진행 사항

- **Tag 컴포넌트 생성**: `components/Tag.tsx`를 생성하여 태그 UI 및 인터랙션 로직을 캡슐화. `Link` 모드와 `button` 모드를 모두 지원.
- **적용 및 리팩토링**:
  - `ExpressionCard`: 기존 버튼 기반 태그를 `Tag` 컴포넌트로 교체.
  - `ExpressionDetailPage`: 기존 `Link` 기반 태그를 `Tag` 컴포넌트로 교체하여 스타일 일관성 확보.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 Tag를 별도 컴포넌트로 분리했나?**

- **A.** 메인 페이지의 카드 내부(버튼 역할)와 상세 페이지(링크 역할)에서 태그의 스타일은 동일해야 하지만 동작이 다름. 이를 `Tag` 컴포넌트 내부에서 `href` 유무에 따라 분기 처리함으로써 코드 중복을 제거하고 유지보수성을 높임.

## 2026-01-01: 표현 상세 페이지 태그 검색 연동

### ✅ 진행 사항

- **태그 인터랙션 구현**: `app/expressions/[id]/page.tsx` 하단의 태그를 클릭 가능한 `Link`로 변경하여, 클릭 시 메인 페이지의 해당 태그 검색 결과로 이동하도록 구현.
- **UI 일관성 유지**: `ExpressionCard`와 동일한 스타일(호버 효과, 색상 등)을 적용하여 시각적 일관성 확보.

### 💬 주요 Q&A 및 의사결정

**Q. 상세 페이지에서 왜 `Link`를 사용했나?**

- **A.** 상세 페이지는 서버 컴포넌트이므로, `useRouter`를 사용하는 클라이언트 로직 대신 표준 `Link` 태그를 사용하는 것이 성능과 SEO 측면에서 유리하다고 판단함.

## 2026-01-01: 검색/필터 기능 완성 및 UI 고도화

### ✅ 진행 사항

- **검색 시스템 구축**: `SearchBar` 컴포넌트를 분리하고, 일반 검색과 태그 검색(`#tag`)을 자동 식별하여 처리하는 로직 구현.
- **필터링 기능 구현**: `FilterBar`를 통해 카테고리별 데이터 필터링 기능 제공. 도메인 필터는 데이터 확충 시점까지 임시 비활성화.
- **UI/UX 폴리싱**:
  - `ExpressionCard`에 생동감 있는 호버 애니메이션(Lift & Glow) 적용.
  - 필터 바에 스크롤 페이드 효과를 추가하여 스크롤 가능 여부를 직관적으로 표시.
  - 클릭 가능한 요소에 `cursor-pointer` 적용 및 시각적 피드백 강화.
- **코드 구조 개선**:
  - UI 설정(`ui-config.ts`), 상수(`constants.ts`), 유틸리티(`utils.ts`) 분리.
  - 컴포넌트(`FilterBar`, `ExpressionCard`)를 클라이언트 컴포넌트로 전환하여 인터랙션 처리.

### 💬 주요 Q&A 및 의사결정

**Q. `#` 검색어 처리는 어떻게 하나?**

- **A.** 사용자가 검색창에 `#idiom`과 같이 입력하면, 이를 검색어가 아닌 '태그 필터'로 인식하여 자동으로 태그 쿼리(`?tag=idiom`)로 변환하도록 구현함.

## 2026-01-01: UI 인터랙션 강화 및 컴포넌트 리팩토링

### ✅ 진행 사항

- **스크롤 UI 개선**: `FilterBar`에 양옆 페이드(Fade) 효과를 추가하여 스크롤 가능 여부를 직관적으로 보여주도록 개선하고, 스크롤바는 숨김 처리함.
- **인터랙션 강화**: `ExpressionCard` 내 태그(`#tag`) 클릭 시 해당 태그로 즉시 필터링되는 기능 구현.
- **UX 디테일 보완**: 모든 클릭 가능한 요소(카테고리 칩, 태그, 닫기 버튼 등)에 `cursor-pointer`를 적용하여 사용성을 높임.
- **리팩토링**:
  - `ExpressionCard`와 `FilterBar`를 `export default`로 전환하고 `use client`를 적용하여 클라이언트 컴포넌트로 변경.
  - 중복되는 UI 설정 로직을 `lib/ui-config.ts`의 `getExpressionUIConfig` 헬퍼 함수로 통합.

### 💬 주요 Q&A 및 의사결정

**Q. 스크롤바를 숨긴 이유는?**

- **A.** 모바일 및 데스크탑에서 깔끔한 UI를 유지하기 위함임. 대신 양옆에 그라데이션 페이드를 동적으로 표시(`useRef`로 스크롤 위치 감지)하여 스크롤 가능함을 힌트로 제공함.

## 2026-01-01: 검색 및 필터링 기능 구현, UI 고도화

### ✅ 진행 사항

- **검색 및 필터 구현**: 메인 페이지 상단에 `FilterBar` 컴포넌트를 추가하여 검색어 입력 및 카테고리(`category`)별 필터링 기능 구현.
- **UI/UX 개선**: `ExpressionCard`에 세련된 호버 애니메이션(Lift & Glow) 적용 및 다크 모드 시인성 강화.
- **상호작용 강화**: `ExpressionCard`를 클라이언트 컴포넌트로 전환하고, 카드 내 태그 클릭 시 즉시 해당 태그로 검색되도록 기능 추가.
- **필터 간소화**: 초기에는 `domain` 필터도 고려했으나, 현재 데이터가 `conversation` 위주이므로 사용자 혼동을 줄이기 위해 우선 `category` 필터에 집중하고 `domain` 필터는 비활성화함 (추후 데이터 확충 시 재활성화 예정).
- **컴포넌트 리팩토링**: `FilterBar` 및 `ExpressionCard`를 `export default` 방식으로 통일하고, UI 설정을 `lib/ui-config.ts`로 중앙화하여 유지보수성 향상.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `FilterBar`에서 Domain 필터를 제거했나?**

- **A.** 현재 DB에 `conversation` 도메인 데이터만 존재하므로, 굳이 탭을 보여주는 것이 불필요하다고 판단함. 카테고리(`business`, `travel` 등) 필터가 사용자에게 더 유용한 탐색 경험을 제공함.

**Q. `ExpressionCard`를 왜 클라이언트 컴포넌트로 바꿨나?**

- **A.** 카드 전체는 상세 페이지 링크(`Link`)로 감싸져 있는데, 내부의 태그 버튼 클릭 시 상세 페이지 이동을 막고(`stopPropagation`) 검색 필터만 적용해야 했음. 이러한 이벤트 처리를 위해 클라이언트 컴포넌트 전환이 필요했음.

## 2026-01-01: 콘텐츠 분류 체계 고도화 및 다국어 확장 대응

### ✅ 진행 사항

- **2단계 분류 체계 도입**: `domain`(대분류: conversation, test 등)과 `category`(소분류: business, travel 등) 컬럼을 추가하여 콘텐츠 확장성 확보.
- **n8n 워크플로우 최적화**: 'Pick Category' 노드를 구조화된 데이터(JSON) 기반으로 리팩토링하고, 쇼핑 카테고리 추가 및 콩글리시 등 특정 문화권 한정 주제 제거.
- **다국어 생성 강화**: Gemini 프롬프트를 고도화하여 한국어, 일본어, 스페인어 콘텐츠를 한 번의 호출로 생성하도록 개선.
- **AI 페르소나 및 톤 교정**: AI가 반말과 존댓말을 혼용하는 문제를 해결하기 위해, 프롬프트에 '반말 사용 금지' 및 '일관된 경어체(Desu-Masu) 사용' 제약 조건을 명시적으로 추가함.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 콩글리시 카테고리를 제거했나?**

- **A.** 서비스가 다국어(일본어, 스페인어 등)로 확장됨에 따라 한국인에게만 유효한 '콩글리시 교정'은 글로벌 사용성 측면에서 부적합하다고 판단함. 대신 모든 언어권에서 공통적으로 유용한 '쇼핑', '여행' 등의 주제로 확장함.

**Q. Domain과 Category를 왜 나누었나?**

- **A.** 추후 '시험 영어(TOEIC 등)', '테마별 단어장' 등으로 서비스를 확장할 때 DB 구조의 대대적인 변경 없이도 유연하게 대응하기 위함임.

## 2025-12-31: 다국어(i18n) 인프라 구축 및 중앙 관리 체계 도입

### ✅ 진행 사항

- **DB 스키마 확장**: `meaning` 및 `content` 컬럼을 JSONB 기반 다국어 구조로 전환 (기존 데이터 `ko` 키로 마이그레이션 전략 수립).
- **동적 언어 감지**: Next.js Middleware를 사용하여 브라우저 언어 설정을 서버 컴포넌트에 전달하는 메커니즘 구현.
- **문자열 중앙 관리**: `lib/i18n/locales/`에 언어별 파일을 분리하고, 하드코딩된 모든 UI 텍스트를 딕셔너리 기반으로 리팩토링.
- **서버 헬퍼 도입**: 서버 컴포넌트 전용 `getI18n()` 유틸리티를 통해 중복 코드를 제거하고 타입 안정성 확보.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 i18n 라이브러리 대신 직접 구현했나?**

- **A.** 현재 프로젝트 규모에서 외부 라이브러리(next-intl 등)는 다소 무거울 수 있음. 미들웨어 + 커스텀 헬퍼 조합으로도 SEO 친화적인 서버 사이드 다국어 처리가 충분히 가능하며, 추후 필요 시 라이브러리로의 전환이 용이하도록 구조화함.

**Q. `dialogue` 내부의 `kr` 키를 왜 `translation`으로 바꿨나?**

- **A.** 일본어(`ja`), 스페인어(`es`) 등 다른 언어 콘텐츠가 추가될 때, 매번 키 이름을 바꿀 필요 없이 동일한 인터페이스(`translation`)를 사용하기 위함임.

## 2025-12-31: AI 프롬프트 고도화 및 페르소나 일관성 확보

### ✅ 진행 사항

- **프롬프트 튜닝**: Gemini Content Generator에 3가지 고품질 예시(`under the weather`, `swamped`, `hang in there`)를 포함하여 생성 품질 상향 평준화.
- **페르소나 교정**: "얘들아", "우리 친구들" 등 특정 대상을 지칭하는 말투를 제거하고, 2030 타겟의 일반적이고 친근한 톤으로 통일.
- **로직 보완**: Gemini의 마크다운 응답을 순수 JSON으로 변환하는 `Parse JSON` 노드 추가 및 Supabase Insert 에러 해결.
- **n8n 백업 체계**: 워크플로우 JSON 내보내기/가져오기 가이드 문서화 및 로컬 백업 파일 생성 (`n8n_data/n8n_workflow_daily_english.json`).

### 💬 주요 Q&A 및 의사결정

**Q. 왜 "얘들아" 같은 표현을 금지했나?**

- **A.** 서비스 타겟이 전 연령층(특히 2030 사회인)으로 확장될 가능성을 고려할 때, 너무 학생 대상인 말투는 브랜드 신뢰도를 떨어뜨릴 수 있음. 따라서 보편적인 친근함을 유지하되 특정 집단을 지칭하지 않도록 제약 조건을 추가함.

**Q. JSON Parsing 에러가 발생한 이유는?**

- **A.** Gemini가 응답 시 `json ... ` 마크다운 태그를 포함하여 문자열로 반환했기 때문임. 이를 정규식으로 제거하고 `JSON.parse`하는 단계를 추가하여 DB Insert가 가능하도록 수정함.

## 2025-12-31: n8n 아키텍처 변경 (Scraping -> AI Generation)

### ✅ 진행 사항

- **n8n 데이터 지속성 확보**: `docker-compose.yml` 수정 (Bind Mount 적용) 및 `.gitignore` 설정 추가 (`n8n_data/`).
- **자동화 전략 대전환**: 기존 외부 블로그 스크래핑 방식에서 **AI 기반 자체 생성 방식**으로 변경.
- **문서 업데이트**:
  - `docs/n8n/expressions/optimization_steps.md`: AI 기반 생성 및 중복 방지 가이드로 전면 수정.
  - `docs/n8n/expressions/workflow_guide.md`: 변경된 아키텍처(Category Selection -> Generator) 반영.
  - `docs/project_context.md`: 시스템 아키텍처 다이어그램 업데이트.

### 💬 주요 Q&A 및 의사결정

**Q. n8n 설정이 자꾸 초기화되는데?**

- **A.** 기존 Docker Volume 방식 대신 프로젝트 내 `./n8n_data` 폴더를 직접 마운트하는 방식(Bind Mount)으로 변경하여, 컨테이너 재시작 시에도 계정 및 워크플로우 데이터가 유지되도록 수정함.

**Q. 왜 스크래핑을 포기하고 AI 생성 방식을 택했나?**

- **A.**
  1.  **안정성**: 외부 블로그의 HTML 구조 변경이나 접속 불가 이슈로부터 완전히 자유로워짐.
  2.  **비용 절감**: 불필요한 HTML 파싱 및 데이터 전송 비용 제거.
  3.  **제어 가능성**: 우리가 원하는 카테고리(비즈니스, 여행 등)를 직접 설정하여 콘텐츠의 방향성을 주도할 수 있음.

**Q. "Gemini Extractor"는 어떻게 변했나?**

- **A.** 기존에는 텍스트에서 표현을 "추출(Extract)"하는 역할이었으나, 이제는 주제를 받아 표현을 "생성(Generate)"하는 역할로 변경됨에 따라 명칭을 `Gemini Expression Generator`로 변경함.

## 2025-12-30: n8n 자동화 파이프라인 완성 및 DB 스키마 분리

### ✅ 진행 사항

- n8n 자동화 워크플로우(스크래핑 -> Gemini -> Supabase) 테스트 성공.
- **다중 프로젝트 전략 적용**: `public` 스키마 대신 `daily_english` 스키마 도입.
- **코드 리팩토링**: DB 스키마명을 `lib/constants.ts`에서 상수로 중앙 관리하고, Supabase 클라이언트(`lib/supabase/*`)가 이를 자동으로 참조하도록 수정.
- **권한 문제 해결**: n8n(Supabase API) 접근 시 발생한 `permission denied` 및 `Invalid schema` 오류를 해결하기 위해 RLS 비활성화 및 명시적 권한 부여 SQL 스크립트 작성 (`database/002_fix_permissions.sql`).

### 💬 주요 Q&A 및 의사결정

**Q. 왜 스키마 이름을 상수로 관리하는가?**

- **A.** 코드 내 `daily_english`라는 문자열이 하드코딩되면 추후 변경 시 누락 위험이 큼. `lib/constants.ts`에 정의하고 이를 `createBrowserSupabase`, `createServerSupabase`에서 참조함으로써 유지보수성을 높이고 실수를 방지함.

**Q. n8n에서 "Invalid schema" 에러가 발생한 이유는?**

- **A.** Supabase의 `public` 스키마 외에 커스텀 스키마를 사용할 경우, Data API 설정에서 해당 스키마를 **Expose** 해주지 않으면 외부에서 접근할 수 없음. 또한, DB 레벨에서도 `GRANT USAGE` 권한이 필요함.

## 2025-12-30: n8n 자동화 환경 구축

### ✅ 진행 사항

- `docker-compose.yml`을 통한 로컬 n8n 실행 환경 설정.
- `n8n/n8n_workflow_template.json` 생성 (가져오기용 워크플로우 템플릿).
- Gemini API 프롬프트 최적화 및 Supabase 연동 로직 설계.
- `feat/n8n-automation-setup` 브랜치 생성 및 작업 시작.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 Docker Compose를 사용하나?**

- **A.** 로컬 환경에서 n8n을 빠르고 일관되게 실행하기 위함이며, 추후 서버 배포 시에도 그대로 활용할 수 있기 때문임.

**Q. n8n 워크플로우 템플릿의 역할은?**

- **A.** 사용자가 n8n GUI에서 하나하나 노드를 만들지 않고, JSON 파일을 `Import from File` 하여 즉시 구조를 잡을 수 있도록 돕기 위함.

## 2025-12-30: 상세 페이지 구현 및 데이터 로직 개선

### ✅ 진행 사항

- 상세 페이지 (`app/expressions/[id]/page.tsx`) 구현.
- 데이터 페칭 로직(`lib/expressions.ts`)을 리팩토링하여 환경 변수 미설정 시에도 우아하게 Mock 데이터로 Fallback 하도록 개선.
- Mock 데이터 분리 (`lib/mock-data.ts`).
- 메인 리스트 카드와 상세 페이지 연동.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `lib/expressions.ts`에서 환경 변수 체크를 제거했나?**

- **A.** 데이터 페칭 로직이 환경 설정에 의존하는 것은 관심사 분리에 위배됨. 대신 `try-catch` 패턴을 사용하여 Supabase 클라이언트 생성이나 요청 실패 시 자연스럽게 Mock 데이터로 대체하는 방식이 더 유연하고 코드 오염이 적다고 판단.

**Q. Mock 데이터는 왜 분리했나?**

- **A.** 메인 페이지와 상세 페이지, 그리고 Fallback 로직 등 여러 곳에서 Mock 데이터를 참조해야 하므로 `lib/mock-data.ts`로 중앙화하여 관리 효율성을 높임.

## 2025-12-30: Supabase 연동 및 메인 UI 구현

### ✅ 진행 사항

- Supabase 클라이언트 설정 (`@supabase/ssr`) 및 환경 변수 템플릿(`.env.local.example`) 생성.
- `createBrowserSupabase`, `createServerSupabase` 유틸리티 함수 구현 (명확한 명명 규칙 적용).
- `Expression` 타입 정의 및 `ExpressionCard` UI 컴포넌트 구현.
- 메인 페이지(`app/page.tsx`) 데이터 페칭 및 ISR(1시간) 적용.

### 💬 주요 Q&A 및 의사결정

**Q. 왜 `createClient` 대신 `createBrowserSupabase`, `createServerSupabase`를 사용하나?**

- **A.** Next.js 환경에서 브라우저와 서버용 클라이언트의 역할(쿠키 접근 등)이 명확히 다르며, 한 파일에서 두 클라이언트를 동시에 다룰 때의 이름 충돌 및 혼동을 방지하기 위함.

**Q. 데이터가 없을 때의 처리는?**

- **A.** 개발 초기 단계에서 UI 확인을 위해 Mock 데이터를 Fallback으로 사용하도록 구현하였으며, 실제 DB 데이터가 있을 경우 이를 우선적으로 보여줌.

## 2025-12-30: 프로젝트 초기 설정 (Project Initialization)

### ✅ 진행 사항

- Next.js 16 + Tailwind CSS + TypeScript 프로젝트 생성 (`speak-mango-en`).
- `src` 디렉토리 없는 구조 채택.
- 문서화 구조 수립 (`docs/` 폴더 내 컨텍스트, 히스토리, 워크스루).
- 데이터베이스 스키마 설계 (Supabase) 및 n8n 워크플로우 가이드 작성.

### 💬 주요 Q&A 및 의사결정

**Q. Next.js + n8n 아키텍처는 적합한가?**

- **A.** 매우 적합함. n8n이 백엔드/데이터 파이프라인 역할을 담당하고, Next.js는 뷰어 역할에 집중하여 효율적임.

**Q. LLM 비용 문제 (OpenAI vs Gemini)?**

- **A.** **Google Gemini 2.5 Flash**를 사용하기로 결정.
- 이유: OpenAI는 유료(종량제)인 반면, Gemini는 강력한 무료 티어(일 1,500회 요청 무료)를 제공하여 초기 운영 비용을 0원으로 만들 수 있음.

**Q. 프로젝트 폴더 구조는?**

- **A.** 최신 Next.js 트렌드에 맞춰 `src` 폴더 없이 루트에 `app`을 두는 구조로 진행.
